---
title: p5.Shader
module: 3D
submodule: Material
file: src/webgl/p5.Shader.js
description: >
  <p>A class to describe a shader program.</p>

  <p>Each <code>p5.Shader</code> object contains a shader program that runs on
  the graphics

  processing unit (GPU). Shaders can process many pixels or vertices at the

  same time, making them fast for many graphics tasks. Theyâ€™re written in a

  language called

  <a
  href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders/"
  target="_blank">GLSL</a>

  and run along with the rest of the code in a sketch.</p>

  <p>A shader program consists of two files, a vertex shader and a fragment

  shader. The vertex shader affects where 3D geometry is drawn on the screen

  and the fragment shader affects color. Once the <code>p5.Shader</code> object
  is

  created, it can be used with the <a href="/reference/p5/shader/">shader()</a>

  function, as in <code>shader(myShader)</code>.</p>

  <p>A shader can optionally describe hooks, which are functions in GLSL that

  users may choose to provide to customize the behavior of the shader. For the

  vertex or the fragment shader, users can pass in an object where each key is

  the type and name of a hook function, and each value is a string with the

  parameter list and default implementation of the hook. For example, to let
  users

  optionally run code at the start of the vertex shader, the options object
  could

  include:</p>

  <pre><code class="language-js">{
    vertex: {
      'void beforeVertex': '() {}'
    }
  }</code></pre><p>Then, in your vertex shader source, you can run a hook by
  calling a function

  with the same name prefixed by <code>HOOK_</code>:</p>

  <pre><code class="language-glsl">void main() {
    HOOK_beforeVertex();
    // Add the rest ofy our shader code here!
  }</code></pre><p>Note: <a
  href="/reference/p5/createShader/">createShader()</a>,

  <a href="/reference/p5/createFilterShader/">createFilterShader()</a>, and

  <a href="/reference/p5/loadShader/">loadShader()</a> are the recommended ways
  to

  create an instance of this class.</p>
line: 1587
isConstructor: true
params:
  - name: renderer
    description: WebGL context for this shader.
    type: p5.RendererGL
  - name: vertSrc
    description: source code for the vertex shader program.
    type: String
  - name: fragSrc
    description: source code for the fragment shader program.
    type: String
  - name: options
    description: >-
      <p>An optional object describing how this shader can

      be augmented with hooks. It can include:</p>

      <ul><li><code>vertex</code>: An object describing the available vertex
      shader hooks.</li><li><code>fragment</code>: An object describing the
      available frament shader hooks.</li></ul>
    optional: 1
    type: Object
example:
  - |-
    <div>
    <code>
    // Note: A "uniform" is a global variable within a shader program.

    // Create a string with the vertex shader program.
    // The vertex shader is called for each vertex.
    let vertSrc = `
    precision highp float;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    attribute vec3 aPosition;
    attribute vec2 aTexCoord;
    varying vec2 vTexCoord;

    void main() {
      vTexCoord = aTexCoord;
      vec4 positionVec4 = vec4(aPosition, 1.0);
      gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
    }
    `;

    // Create a string with the fragment shader program.
    // The fragment shader is called for each pixel.
    let fragSrc = `
    precision highp float;

    void main() {
      // Set each pixel's RGBA value to yellow.
      gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
    }
    `;

    function setup() {
      createCanvas(100, 100, WEBGL);

      // Create a p5.Shader object.
      let myShader = createShader(vertSrc, fragSrc);

      // Apply the p5.Shader object.
      shader(myShader);

      // Style the drawing surface.
      noStroke();

      // Add a plane as a drawing surface.
      plane(100, 100);

      describe('A yellow square.');
    }
    </code>
    </div>

    <div>
    <code>
    // Note: A "uniform" is a global variable within a shader program.

    let mandelbrot;

    async function setup() {
      mandelbrot = await loadShader('/assets/shader.vert', '/assets/shader.frag');
      createCanvas(100, 100, WEBGL);

      // Use the p5.Shader object.
      shader(mandelbrot);

      // Set the shader uniform p to an array.
      mandelbrot.setUniform('p', [-0.74364388703, 0.13182590421]);

      describe('A fractal image zooms in and out of focus.');
    }

    function draw() {
      // Set the shader uniform r to a value that oscillates between 0 and 2.
      mandelbrot.setUniform('r', sin(frameCount * 0.01) + 1);

      // Add a quad as a display surface for the shader.
      quad(-1, -1, 1, -1, 1, 1, -1, 1);
    }
    </code>
    </div>
methods:
  version:
    description: >
      <p>Shaders are written in <a
      href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders/">GLSL</a>,
      but

      there are different versions of GLSL that it might be written in.</p>

      <p>Calling this method on a <code>p5.Shader</code> will return the GLSL
      version it uses, either <code>100 es</code> or <code>300 es</code>.

      WebGL 1 shaders will only use <code>100 es</code>, and WebGL 2 shaders may
      use either.</p>
    path: p5.Shader/version
  inspectHooks:
    description: >-
      <p>Logs the hooks available in this shader, and their current
      implementation.</p>

      <p>Each shader may let you override bits of its behavior. Each bit is
      called

      a hook. A hook is either for the vertex shader, if it affects the

      position of vertices, or in the fragment shader, if it affects the pixel

      color. This method logs those values to the console, letting you know what

      you are able to use in a call to

      <a href="/reference/p5.Shader/modify/"><code>modify()</code></a>.</p>

      <p>For example, this shader will produce the following output:</p>

      <pre><code class="language-js">myShader = baseMaterialShader().modify({
        declarations: 'uniform float time;',
        'vec3 getWorldPosition': `(vec3 pos) {
          pos.y += 20. * sin(time * 0.001 + pos.x * 0.05);
          return pos;
        }`
      });

      myShader.inspectHooks();</code></pre><pre><code>==== Vertex shader hooks:
      ====

      void beforeVertex() {}

      vec3 getLocalPosition(vec3 position) { return position; }

      [MODIFIED] vec3 getWorldPosition(vec3 pos) {
            pos.y += 20. * sin(time * 0.001 + pos.x * 0.05);
            return pos;
          }
      vec3 getLocalNormal(vec3 normal) { return normal; }

      vec3 getWorldNormal(vec3 normal) { return normal; }

      vec2 getUV(vec2 uv) { return uv; }

      vec4 getVertexColor(vec4 color) { return color; }

      void afterVertex() {}


      ==== Fragment shader hooks: ====

      void beforeFragment() {}

      Inputs getPixelInputs(Inputs inputs) { return inputs; }

      vec4 combineColors(ColorComponents components) {
                      vec4 color = vec4(0.);
                      color.rgb += components.diffuse * components.baseColor;
                      color.rgb += components.ambient * components.ambientColor;
                      color.rgb += components.specular * components.specularColor;
                      color.rgb += components.emissive;
                      color.a = components.opacity;
                      return color;
                    }
      vec4 getFinalColor(vec4 color) { return color; }

      void afterFragment() {}</code></pre>
    path: p5.Shader/inspectHooks
  modify:
    description: >-
      <p>Returns a new shader, based on the original, but with custom snippets

      of shader code replacing default behaviour.</p>

      <p>Each shader may let you override bits of its behavior. Each bit is
      called

      a hook. For example, a hook can let you adjust positions of vertices, or

      the color of a pixel. You can inspect the different hooks available by
      calling

      <a
      href="/reference/p5.Shader/inspectHooks/"><code>yourShader.inspectHooks()</code></a>.
      You can

      also read the reference for the default material, normal material, color,
      line, and point shaders to

      see what hooks they have available.</p>

      <p><code>modify()</code> can be passed a function as a parameter. Inside,
      you can override hooks

      by calling them as functions. Each hook will take in a callback that takes
      in inputs

      and is expected to return an output. For example, here is a function that
      changes the

      material color to red:</p>

      <pre><code class="language-js example">let myShader;


      function setup() {
        createCanvas(200, 200, WEBGL);
        myShader = baseMaterialShader().modify(() => {
          getPixelInputs((inputs) => {
            inputs.color = [inputs.texCoord, 0, 1];
            return inputs;
          });
        });
      }


      function draw() {
        background(255);
        noStroke();
        shader(myShader); // Apply the custom shader
        plane(width, height); // Draw a plane with the shader applied
      }</code></pre><p>In addition to calling hooks, you can create uniforms,
      which are special variables

      used to pass data from p5.js into the shader. They can be created by
      calling <code>uniform</code> + the

      type of the data, such as <code>uniformFloat</code> for a number of
      <code>uniformVector2</code> for a two-component vector.

      They take in a function that returns the data for the variable. You can
      then reference these

      variables in your hooks, and their values will update every time you apply

      the shader with the result of your function.</p>

      <pre><code class="language-js example">let myShader;


      function setup() {
        createCanvas(200, 200, WEBGL);
        myShader = baseMaterialShader().modify(() => {
          // Get the current time from p5.js
          let t = uniformFloat(() => millis());

          getPixelInputs((inputs) => {
            inputs.color = [
              inputs.texCoord,
              sin(t * 0.01) / 2 + 0.5,
              1,
            ];
            return inputs;
          });
        });
      }


      function draw() {
        background(255);
        noStroke(255);
        shader(myShader); // Apply the custom shader
        plane(width, height); // Draw a plane with the shader applied
      }</code></pre><p>p5.strands functions are special, since they get turned
      into a shader instead of being

      run like the rest of your code. They only have access to p5.js functions,
      and variables

      you declare inside the <code>modify</code> callback. If you need access to
      local variables, you

      can pass them into <code>modify</code> with an optional second parameter,
      <code>variables</code>. If you are

      using instance mode, you will need to pass your sketch object in this
      way.</p>

      <pre><code class="language-js example">new p5((sketch) => {
        let myShader;

        sketch.setup = function() {
          sketch.createCanvas(200, 200, sketch.WEBGL);
          myShader = sketch.baseMaterialShader().modify(() => {
            sketch.getPixelInputs((inputs) => {
              inputs.color = [inputs.texCoord, 0, 1];
              return inputs;
            });
          }, { sketch });
        }

        sketch.draw = function() {
          sketch.background(255);
          sketch.noStroke();
          sketch.shader(myShader); // Apply the custom shader
          sketch.plane(sketch.width, sketch.height); // Draw a plane with the shader applied
        }
      });</code></pre><p>You can also write GLSL directly in <code>modify</code>
      if you need direct access. To do so,

      <code>modify()</code> takes one parameter, <code>hooks</code>, an object
      with the hooks you want

      to override. Each key of the <code>hooks</code> object is the name

      of a hook, and the value is a string with the GLSL code for your hook.</p>

      <p>If you supply functions that aren't existing hooks, they will get added
      at the start of

      the shader as helper functions so that you can use them in your hooks.</p>

      <p>To add new <a href="/reference/p5.Shader/setUniform/">uniforms</a> to
      your shader, you can pass in a <code>uniforms</code> object containing

      the type and name of the uniform as the key, and a default value or
      function returning

      a default value as its value. These will be automatically set when the
      shader is set

      with <code>shader(yourShader)</code>.</p>

      <pre><code class="language-js example">let myShader;


      function setup() {
        createCanvas(200, 200, WEBGL);
        myShader = baseMaterialShader().modify({
          uniforms: {
            'float time': () => millis() // Uniform for time
          },
          'Vertex getWorldInputs': `(Vertex inputs) {
            inputs.position.y +=
              20. * sin(time * 0.001 + inputs.position.x * 0.05);
            return inputs;
          }`
        });
      }


      function draw() {
        background(255);
        shader(myShader); // Apply the custom shader
        lights();         // Enable lighting
        noStroke();       // Disable stroke
        fill('red');      // Set fill color to red
        sphere(50);       // Draw a sphere with the shader applied
      }</code></pre><p>You can also add a <code>declarations</code> key, where
      the value is a GLSL string declaring

      custom uniform variables, globals, and functions shared

      between hooks. To add declarations just in a vertex or fragment shader,
      add

      <code>vertexDeclarations</code> and <code>fragmentDeclarations</code>
      keys.</p>

      <pre><code class="language-js example">let myShader;


      function setup() {
        createCanvas(200, 200, WEBGL);
        myShader = baseMaterialShader().modify({
          // Manually specifying a uniform
          declarations: 'uniform float time;',
          'Vertex getWorldInputs': `(Vertex inputs) {
            inputs.position.y +=
              20. * sin(time * 0.001 + inputs.position.x * 0.05);
            return inputs;
          }`
        });
      }


      function draw() {
        background(255);
        shader(myShader);
        myShader.setUniform('time', millis());
        lights();
        noStroke();
        fill('red');
        sphere(50);
      }</code></pre>
    path: p5.Shader/modify
  copyToContext:
    description: >
      <p>Copies the shader from one drawing context to another.</p>

      <p>Each <code>p5.Shader</code> object must be compiled by calling

      <a href="/reference/p5/shader/">shader()</a> before it can run.
      Compilation happens

      in a drawing context which is usually the main canvas or an instance of

      <a href="/reference/p5/p5.Graphics">p5.Graphics</a>. A shader can only be
      used in the

      context where it was compiled. The <code>copyToContext()</code> method
      compiles the

      shader again and copies it to another drawing context where it can be

      reused.</p>

      <p>The parameter, <code>context</code>, is the drawing context where the
      shader will be

      used. The shader can be copied to an instance of

      <a href="/reference/p5/p5.Graphics">p5.Graphics</a>, as in

      <code>myShader.copyToContext(pg)</code>. The shader can also be copied
      from a

      <a href="/reference/p5/p5.Graphics">p5.Graphics</a> object to the main
      canvas using

      the <code>p5.instance</code> variable, as in
      <code>myShader.copyToContext(p5.instance)</code>.</p>

      <p>Note: A <a href="/reference/p5/p5.Shader">p5.Shader</a> object created
      with

      <a href="/reference/p5/createShader/">createShader()</a>,

      <a href="/reference/p5/createFilterShader/">createFilterShader()</a>, or

      <a href="/reference/p5/loadShader/">loadShader()</a>

      can be used directly with a <a
      href="/reference/p5/p5.Framebuffer">p5.Framebuffer</a>

      object created with

      <a href="/reference/p5/createFramebuffer/">createFramebuffer()</a>. Both
      objects

      have the same context as the main canvas.</p>
    path: p5.Shader/copyToContext
  setUniform:
    description: >
      <p>Sets the shaderâ€™s uniform (global) variables.</p>

      <p>Shader programs run on the computerâ€™s graphics processing unit (GPU).

      They live in part of the computerâ€™s memory thatâ€™s completely separate

      from the sketch that runs them. Uniforms are global variables within a

      shader program. They provide a way to pass values from a sketch running

      on the CPU to a shader program running on the GPU.</p>

      <p>The first parameter, <code>uniformName</code>, is a string with the
      uniformâ€™s name.

      For the shader above, <code>uniformName</code> would be
      <code>'r'</code>.</p>

      <p>The second parameter, <code>data</code>, is the value that should be
      used to set the

      uniform. For example, calling <code>myShader.setUniform('r', 0.5)</code>
      would set

      the <code>r</code> uniform in the shader above to <code>0.5</code>. data
      should match the

      uniformâ€™s type. Numbers, strings, booleans, arrays, and many types of

      images can all be passed to a shader with <code>setUniform()</code>.</p>
    path: p5.Shader/setUniform
chainable: false
---


# p5.Shader
